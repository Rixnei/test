apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  # Тут я не до конца понял, у меня в каждой зоне должно быть по 4 приложения или всего 4 но, что бы хотя бы одно было в каждой зоне.
  # Тестировал Deployment в Linode с 3 нодами.
  # Не знаю с чего я решил, что распределение по странам :D.
  # Если в каждой зоне по 4 приложения я бы запустил 3 Deployment'а но только с 1 значение страны. Сноска 1.
  # Уверен, что можно сделать лучше, но я сходу не придумал.
  replicas: 4
  # Стратегию выбрал помедленнее разворачиваться(так как приложение будет заменяться по одному), но в тоже время возможность принять пиковую нагрузку
  # Ну и пытался учесть максимальную отказоустойчивость + минимальное потребление ресурсов.
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 0
      maxSurge: 1
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      # Тут происходит магия распределения подов по нодам с нужным значением ключа-country. "kubectl label nodes node-name country=sin"
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            - matchExpressions:
              - key: country
                operator: In
                # Сноска 1.
                values:
                - sin
                - la
                - hk
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values:
                  - nginx
              topologyKey: "kubernetes.io/hostname"
      containers:
      # Взял веб-сервер "Аля веб-приложение"
      - name: nginx
        image: nginx:1.14.2
        # Значения для лимита CPU выбрал 750m так, как посчитал, что для запуска и первых запросов этого хватит. А для дальнейшего потребления оставил 0.1CPU.
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "750m"
        ports:
        - containerPort: 80
        # Проверка на доступность порта.
        startupProbe:
          tcpSocket:
            port: 80
          # Приложение стартует от 5 секунд, проверять раньше нет смысла.
          initialDelaySeconds: 5
          # Проверка каждую секунду.
          periodSeconds: 1
          # 7 попыток, так как в среднем стартует 5-10 секунд. С небольшим запасом, на всякий случай, если стартует больше значит, что то пошло не так.
          failureThreshold: 7
